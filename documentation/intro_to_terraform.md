## _Introduction to Terraform_
Contents:

- [State file](#state-file)
- [Providers](#providers)
- [Terraform commands](#terraform-commands)
- [Terraform variables and workspaces](#terraform-variables-and-workspaces)
- [Interpreting a Terraform Plan](#interpreting-a-terraform-plan)
- [Troubleshooting](#troubleshooting)

[Terraform](https://developer.hashicorp.com/terraform) is a declarative Infrastructure as Code (IaC) tool for provisioning virtual infrastructure. It is a modular tool that works with multiple Cloud Service Providers (CSPs). Infrastructure is defined in reuseable human-readable configuration files that can be versioned and shared.

Terraform is _declarative_ which means that code is written to describe the desired end state, as opposed to the more familiar _procedural_ paradigm in which code defines a series of steps to take. Terraform determines the procedure it needs to follow automatically, and presents this to the user for approval before execution. This is known as the _terraform plan_. We discuss how to [interpret a Terraform plan](#interpreting-a-terraform-plan) below.

### State file
Terraform keeps track of the effects of actions it has performed in a _state file_. The state file acts as Terraform's source of truth for any changes it needs to make. It is Terraform's "concept of reality" thus it is important to never remove or manually edit the state file. While it is possible to store the state file in many different ways, the default way (and the way we use here) is an on-disk file that is created alongside the Terraform code; it is named `terraform.tfstate`. *Do not remove or modify this file!*

### Providers
In order to work with multiple CSPs, Terraform is written to work with external program objects known as _providers_. The needed providers are defined in code and are downloaded when Terraform is initialized. They are stored in a directory named `.terraform/` alongside the Terraform code.

### Terraform commands
#### terraform init
Before Terraform can be used, `terraform init` must in run in the project directory. This command creates the `.terraform/` directory and downloads the necessary providers into it. A file named `.terraform.lock.hcl` is also created at initilization time; this file contains metadata about the providers in use for the current project. These files may be deleted, if needed, as they can be regenerated by re-running `terraform init`, however, this should not be necessary unless troubleshooting.

If being run for the first time, `terraform init` will also create an empty state file.
#### terraform plan
`terraform plan` compares the contents of the current state file with the resources defined by the Terraform code. If any differences are detected, a procedure for reconciling the differences is presented to the user. The plan can be saved for later execution if desired. **Note:** In most cases, this does not need to be run independently, as a plan is also generated by `terraform apply` and can be executed immediately.
#### terraform apply
`terraform apply` generates a plan and presents it for immediate approval for execution. This is the typical way of creating resources with Terraform.

Because Terraform wants to reconcile the defined code with the current state, `terraform apply` may actually destroy resources if they have been removed from the code. For instance, we define a students file with these contents:

```
students = ["alice", "bob"]
```
If we remove "bob" from the list of students and run `terraform apply`, Bob's resources will be removed while Alice's will not be affected.

We can also add students without affecting running resources. By changing the students file to:

```
students = ["alice", "bob", "carol"]
```
and then running `terraform apply` new resources will be created for Carol while Alice's and Bob's will be left alone.
#### terraform destroy
`terraform destroy` will remove all the resources defined in the state file.

### Terraform variables and workspaces
***This section describes an advanced use case that is only necessary if cloud resources for multiple labs need to exist at the same time.***

It may sometimes be necessary to deploy multiple sets of resources that will exist at the same time. For our purposes this might look like multiple sections or multiple labs being run simultaneously. Terraform facilitates the ability to create multiple, independent sets of resources via the use of *workspaces*. Before we talk about workspaces it is useful to talk about variables.

Terraform variables should be definied in _variable files_. Variable files are files with a `.tfvars` extension. Any variable file that that ends in `.auto.tfvars` is automatically used by Terraform, but any `.tfvars` file may be manually selected.

We can combine workspaces with variable files in a useful way. The following is an example. Suppose a Physical Chemistry lab meets on Tuesday, and the students will be performing calculations that last for the rest of the week. There is also a General Chemistry lab meeting on Thursday that will need resources for a few hours. Without workspaces, running `terraform apply` for General Chem will destroy the running Physical Chem resources.

With workspaces, we use the `terraform workspace new` command to create and switch to a workspace. All of the workspace commands take a single argument that is the name of the workspace.

**Note:** By default, all Terraform operations take place in a workspace named `default`.

```
terraform workspace new pchem
```

Then _rename_ the three `.auto.tfvars` files to no longer include `.auto` and to be unique for the workspace.

```
mv instance_params.auto.tfvars instance_params.pchem.tfvars
mv students.auto.tfvars students.pchem.tfvars
mv workload.auto.tfvars workload.pchem.tfvars
```
Now specifiy the three variable files on the command line:

```
terraform apply -var-file=instance_params.pchem.tfvars -var-file=students.pchem.tfvars -var-file=workload.pchem.tfvars
```

Similarly, create three `.genchem.tfvars` files, and a 'genchem' workspace at the appointed time:

>Note: The naming convention of the `.tfvars` files does not need to match the name of the workspace, but you may find the paradigm convenient.
>
>WARNING! The student usernames need to be unique across workspaces!

```
terraform workspace new genchem
terraform apply -var-file=instance_params.genchem.tfvars -var-file=students.genchem.tfvars -var-file=workload.genchem.tfvars
```

You will now have two sets of machines running, each set in its own workspace. You can view a list of your workspaces with the `terraform workspace list` command.

When the General Chem lab has completed, you still need to specify the -var-file arguments to perform the destroy. For example:

```
terraform destroy -var-file=instance_params.genchem.tfvars -var-file=students.genchem.tfvars -var-file=workload.genchem.tfvars
```
and similarly for Physical Chem, first switching to the existing pchem workspace with the `terraform workspace select` command:

```
terraform workspace select pchem
terraform destroy -var-file=instance_params.pchem.tfvars -var-file=students.pchem.tfvars -var-file=workload.pchem.tfvars
```

If desired, you can delete a workspace with `terraform workspace delete <name>`. 

>WARNING! Deleting a workspace will NOT destroy the resources in the workspace. If you plan to destroy a workspace, run `terraform destroy -var-file=<filename> [...]` in the workspace first!

### Interpreting a Terraform Plan
When `terraform apply` is run, the *plan* is displayed before being executed. The final line of the output will be similar to:

```
Plan: <X> to add, <Y> to change, <Z> to destroy.
```
where X, Y and Z are the number of resources to be created, modified, or destroyed.

The plan will also include a list of resources and their attibutes, each of which will be marked with `+` (create), `-` (destroy), `~` (change) or `-/+` (destroy and re-create). When a resource needs to be destroyed and created anew, X and Z will both be incremented.

Destroy and re-create happens when a resource cannot be modified in place. If, for example the workload file is modified with new commands to be run on instance startup, that cannot happen on an already running instance, so the instance(s) would be destroyed and re-created. Similarly, an instance type cannot be changed while it is running, so changes to the instance parameters file will generally also result in a destroy/create.

For our present purpose, we should usually expect to see all resources being created (when running `terraform apply`) or destroyed (when running `terraform destroy`), except for example when adding or removing one or more student users to an already running lab. See the [terraform apply](#terraform-apply) section above for an example.

Note that if you apply or destroy multiple times in a row, you will see a `No changes` message with a brief explanation.

### Troubleshooting
Because Terraform is interacting with remote CSPs, the most common errors encountered will be from the CSP. If an error is encountered when destroying infrastructure, in most cases you will want to re-run `terraform destroy`.

For errors when running `terraform apply` you may encounter:
##### Resource limits imposed by AWS
Newly created AWS accounts have a limit on the number of CPU cores that can be provisioned. This limit can be increased by AWS support. We have included [instructions](https://github.com/wintercompchem/byodcloud/blob/main/documentation/instructions_for_use_instructor.md#requesting-a-quota-increase-in-aws) to request this increase elsewhere in our documentation.

If you encounter this error, run `terraform destroy`, request the increase and run `terraform apply` again after the increase has been granted.
##### Temporary resource limits
Occasionally AWS will run out of capacity for a particular instance family in a particular region. If you encounter this error, you have two choices:

1. Use a different instance family: update the instance parameter file to use an instance type in a different family (e.g. change from c7a to c7i). Once this is done, run `terraform apply` again. **Note:** In this case, any c7a instances that had already been created will be destroyed and new c7i instances will be created instead.
2. Use a different region: run `terraform destroy`, update the instance parameter file to a different region and run `terraform apply` again. **Note:** Because each AWS region operates independently, you *must* `terraform destroy` in the original region, or you will continue to be charged for any resources from a partial apply in that region.

##### Application Program Interface (API) timeouts
Rarely a CSP will not be able to respond in time. In these cases, 
Terraform will automatically retry, but it may timeout after a series of failures. If you encounter this, in most cases you can simply re-run the apply.